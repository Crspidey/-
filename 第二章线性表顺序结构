//当我们定义一个指针的时候，直接让它指向NULL。因为NULL在宏定义是#define NULL(void *) 0 它代表的是零地址，而零地址是不能进行读写操作的。
#include<iostream>
using namespace std;
#define LIST_INIT_SIZE 100//顺序表存储空间初始分配量
#define LISTINCREMENT 10//顺序表存储空间分配增量
struct List {
	int *elem;//存储空间基本地址
	int length;//当前顺序表的长度
	int listsize;//当前分配的存储容量
};
bool compare(int a, int b)
{
	if (a == b)
		return true;
	else
		return false;
}
void InitList(List&L)
{
	L.elem = (int*)malloc(LISTINCREMENT* sizeof(int));
		if(L.elem==NULL)
		cout<<"内存申请失败"<<endl;
		L.length = 0;
		L.listsize =LIST_INIT_SIZE ;
}
void DestroyList(List&L)
{
	free(L.elem);
	L.elem = NULL;
	L.length = 0;
	L.listsize = 0;
}
void ClearList(List&L)
{
	L.length = 0;
}
bool ListEmpty(List L)
{
	if (L.length == 0)
		return true;
	else
		return false;
}
int ListLength(List L)
{
		return L.length;
}
int GetElme(List L,int i,int&e)
{
	e = L.elem[i-1];
	return e;
}
int LocateElem(List L, int e,bool(compare)(int a,int b))
{
	int i = 1;
	while (true)
	{
		if (compare(L.elem[i-1], e))
		{
			return i;
			break;
		}
		if (i > L.length)
			break;
		i++;
    }
}
int*PriorElem(List L, int cur_e,int *pre_e)	//int*pre_e=(int*)malloc(sizeof(int));
{
	if (L.elem[0] == cur_e&&cur_e<L.length)
		return NULL;
	for (int i=1; i <=L.length; i++)
	{
		if (L.elem[i] == cur_e)
		{
			pre_e = L.elem + i-1;
			return pre_e;
		}
	}
}
int*NextListElem(List L, int cur_e, int*pre_e)//	int*pre_e = new int;
{
	int i = 0;
	if (L.elem[L.length] != cur_e)
	{
		for (; i < L.length; i++)
		{
			if (L.elem[i] == cur_e)
			{
				pre_e = L.elem + i + 1;
				return pre_e;
			}
		}
	}
	else
		return NULL;
	//if (L.elem[L.length] == cur_e&&cur_e<L.length)
		//return NULL;
}
void ListInser(List&L, int e, int i)
{
	if ((L.length + 1) * sizeof(int) > LIST_INIT_SIZE||i<1||i>L.length+1)
		cout << "无法插入！" << endl;
	else
	{
		for (int j = L.length; j <= i; j--)
			L.elem[j + 1] = L.elem[j];
	}
	L.elem[i - 1] = e;
	++L.length;
}

int ListDelete(List&L, int e, int i)
{
	if (i<1 && i>L.length)
		return 0;
	else 
	{
		e = L.elem[i - 1];
		for (int j = i; i < L.length; j++)
			L.elem[j - 1] = L.elem[j];
		--L.length;
		return e;
	}
}

